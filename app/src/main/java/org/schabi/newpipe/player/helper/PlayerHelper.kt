package org.schabi.newpipe.player.helper

import android.annotation.SuppressLint
import android.content.Context
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.provider.Settings
import android.view.accessibility.CaptioningManager
import androidx.annotation.IntDef
import androidx.core.content.ContextCompat
import androidx.preference.PreferenceManager
import com.google.android.exoplayer2.PlaybackParameters
import com.google.android.exoplayer2.Player
import com.google.android.exoplayer2.SeekParameters
import com.google.android.exoplayer2.source.ProgressiveMediaSource
import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection
import com.google.android.exoplayer2.trackselection.ExoTrackSelection
import com.google.android.exoplayer2.ui.AspectRatioFrameLayout
import com.google.android.exoplayer2.ui.AspectRatioFrameLayout.ResizeMode
import com.google.android.exoplayer2.ui.CaptionStyleCompat
import com.google.android.exoplayer2.util.MimeTypes
import org.schabi.newpipe.R
import org.schabi.newpipe.extractor.MediaFormat
import org.schabi.newpipe.extractor.stream.StreamInfo
import org.schabi.newpipe.extractor.stream.StreamInfoItem
import org.schabi.newpipe.extractor.stream.SubtitlesStream
import org.schabi.newpipe.extractor.utils.Utils
import org.schabi.newpipe.player.playqueue.PlayQueue
import org.schabi.newpipe.player.playqueue.PlayQueueItem
import org.schabi.newpipe.player.playqueue.SinglePlayQueue
import org.schabi.newpipe.util.ListHelper.isMeteredNetwork
import java.text.DecimalFormat
import java.text.NumberFormat
import java.util.*
import java.util.concurrent.TimeUnit

object PlayerHelper {
    private val STRING_BUILDER = StringBuilder()
    private val STRING_FORMATTER = Formatter(STRING_BUILDER, Locale.getDefault())
    private val SPEED_FORMATTER: NumberFormat = DecimalFormat("0.##x")
    private val PITCH_FORMATTER: NumberFormat = DecimalFormat("##%")

    ////////////////////////////////////////////////////////////////////////////
    // Exposed helpers
    ////////////////////////////////////////////////////////////////////////////
    fun getTimeString(milliSeconds: Int): String {
        val seconds = (milliSeconds % 60000) / 1000
        val minutes = (milliSeconds % 3600000) / 60000
        val hours = (milliSeconds % 86400000) / 3600000
        val days = (milliSeconds % (86400000 * 7)) / 86400000

        STRING_BUILDER.setLength(0)
        return (when {
            days > 0 -> STRING_FORMATTER.format("%d:%02d:%02d:%02d", days, hours, minutes, seconds)
            hours > 0 -> STRING_FORMATTER.format("%d:%02d:%02d", hours, minutes, seconds)
            else -> STRING_FORMATTER.format("%02d:%02d", minutes, seconds)
        }).toString()
    }

    @JvmStatic
    fun formatSpeed(speed: Double): String {
        return SPEED_FORMATTER.format(speed)
    }

    @JvmStatic
    fun formatPitch(pitch: Double): String {
        return PITCH_FORMATTER.format(pitch)
    }

    fun subtitleMimeTypesOf(format: MediaFormat): String {
        return when (format) {
            MediaFormat.VTT -> MimeTypes.TEXT_VTT
            MediaFormat.TTML -> MimeTypes.APPLICATION_TTML
            else -> throw IllegalArgumentException("Unrecognized mime type: " + format.name)
        }
    }

    fun captionLanguageOf(context: Context, subtitles: SubtitlesStream): String {
        val displayName = subtitles.displayLanguageName
        return displayName + (if (subtitles.isAutoGenerated) " (${context.getString(R.string.caption_auto_generated)})" else "")
    }

    fun captionLanguageStemOf(language: String): String {
        if (!language.contains("(") || !language.contains(")")) return language

        if (language.startsWith("(")) {
            // language text is right-to-left
            val parts = language.split("\\)".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            return parts[parts.size - 1].trim { it <= ' ' }
        }

        return language.split("\\(".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0].trim { it <= ' ' }
    }

    fun resizeTypeOf(context: Context, resizeMode: @ResizeMode Int): String {
        return when (resizeMode) {
            AspectRatioFrameLayout.RESIZE_MODE_FIT -> context.resources.getString(R.string.resize_fit)
            AspectRatioFrameLayout.RESIZE_MODE_FILL -> context.resources.getString(R.string.resize_fill)
            AspectRatioFrameLayout.RESIZE_MODE_ZOOM -> context.resources.getString(R.string.resize_zoom)
            AspectRatioFrameLayout.RESIZE_MODE_FIXED_HEIGHT, AspectRatioFrameLayout.RESIZE_MODE_FIXED_WIDTH -> throw IllegalArgumentException(
                "Unrecognized resize mode: $resizeMode")
            else -> throw IllegalArgumentException("Unrecognized resize mode: $resizeMode")
        }
    }

    /**
     * Given a [StreamInfo] and the existing queue items,
     * provide the [SinglePlayQueue] consisting of the next video for auto queueing.
     *
     *
     * This method detects and prevents cycles by naively checking
     * if a candidate next video's url already exists in the existing items.
     *
     *
     *
     * The first item in [StreamInfo.getRelatedItems] is checked first.
     * If it is non-null and is not part of the existing items, it will be used as the next stream.
     * Otherwise, a random stream with non-repeating url will be selected
     * from the [StreamInfo.getRelatedItems]. Non-stream items are ignored.
     *
     *
     * @param info          currently playing stream
     * @param existingItems existing items in the queue
     * @return [SinglePlayQueue] with the next stream to queue
     */
    fun autoQueueOf(info: StreamInfo, existingItems: List<PlayQueueItem>): PlayQueue? {
        val urls: MutableSet<String> = HashSet(existingItems.size)
        for (item in existingItems) {
            urls.add(item.url)
        }

        val relatedItems = info.relatedItems
        if (Utils.isNullOrEmpty(relatedItems)) return null

        if (relatedItems[0] is StreamInfoItem && !urls.contains(relatedItems[0].url)) {
            return getAutoQueuedSinglePlayQueue(relatedItems[0] as StreamInfoItem)
        }

        val autoQueueItems: MutableList<StreamInfoItem?> = ArrayList()
        for (item in relatedItems) {
            if (item is StreamInfoItem && !urls.contains(item.getUrl())) {
                autoQueueItems.add(item)
            }
        }

        autoQueueItems.shuffle()
        return if (autoQueueItems.isEmpty()) null else getAutoQueuedSinglePlayQueue(autoQueueItems[0])
    }

    ////////////////////////////////////////////////////////////////////////////
    // Settings Resolution
    ////////////////////////////////////////////////////////////////////////////
    fun isResumeAfterAudioFocusGain(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.resume_on_audio_focus_gain_key), false)
    }

    fun getActionForRightGestureSide(context: Context): String? {
        return getPreferences(context).getString(context.getString(R.string.right_gesture_control_key), context.getString(R.string.default_right_gesture_control_value))
    }

    fun getActionForLeftGestureSide(context: Context): String? {
        return getPreferences(context).getString(context.getString(R.string.left_gesture_control_key), context.getString(R.string.default_left_gesture_control_value))
    }

    fun isStartMainPlayerFullscreenEnabled(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.start_main_player_fullscreen_key), false)
    }

    fun isAutoQueueEnabled(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.auto_queue_key), false)
    }

    fun isClearingQueueConfirmationRequired(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.clear_queue_confirmation_key), false)
    }

    @MinimizeMode
    fun getMinimizeOnExitAction(context: Context): Int {
        val action = getPreferences(context).getString(context.getString(R.string.minimize_on_exit_key), "")
        return when (action) {
            context.getString(R.string.minimize_on_exit_popup_key) -> {
                MinimizeMode.MINIMIZE_ON_EXIT_MODE_POPUP
            }
            context.getString(R.string.minimize_on_exit_none_key) -> {
                MinimizeMode.MINIMIZE_ON_EXIT_MODE_NONE
            }
            else -> {
                MinimizeMode.MINIMIZE_ON_EXIT_MODE_BACKGROUND // default
            }
        }
    }

    @AutoplayType
    fun getAutoplayType(context: Context): Int {
        val type = getPreferences(context).getString(context.getString(R.string.autoplay_key), "")
        return when (type) {
            context.getString(R.string.autoplay_always_key) -> {
                AutoplayType.AUTOPLAY_TYPE_ALWAYS
            }
            context.getString(R.string.autoplay_never_key) -> {
                AutoplayType.AUTOPLAY_TYPE_NEVER
            }
            else -> {
                AutoplayType.AUTOPLAY_TYPE_WIFI // default
            }
        }
    }

    fun isAutoplayAllowedByUser(context: Context): Boolean {
        return when (getAutoplayType(context)) {
            AutoplayType.AUTOPLAY_TYPE_NEVER -> false
            AutoplayType.AUTOPLAY_TYPE_WIFI -> !isMeteredNetwork(context)
            AutoplayType.AUTOPLAY_TYPE_ALWAYS -> true
            else -> true
        }
    }

    fun getSeekParameters(context: Context): SeekParameters {
        return if (isUsingInexactSeek(context)) SeekParameters.CLOSEST_SYNC else SeekParameters.EXACT
    }

    @JvmStatic
    val preferredCacheSize: Long
        get() = 64 * 1024 * 1024L

    val preferredFileSize: Long
        get() = 2 * 1024 * 1024L // ExoPlayer CacheDataSink.MIN_RECOMMENDED_FRAGMENT_SIZE

    val qualitySelector: ExoTrackSelection.Factory
        get() = AdaptiveTrackSelection.Factory(
            1000,
            AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
            AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
            AdaptiveTrackSelection.DEFAULT_BANDWIDTH_FRACTION)

    val isUsingDSP: Boolean
        get() = true

    fun getCaptionStyle(context: Context): CaptionStyleCompat {
        val captioningManager = ContextCompat.getSystemService(context, CaptioningManager::class.java)
        if (captioningManager == null || !captioningManager.isEnabled) return CaptionStyleCompat.DEFAULT

        return CaptionStyleCompat.createFromCaptionStyle(captioningManager.userStyle)
    }

    /**
     * Get scaling for captions based on system font scaling.
     *
     * Options:
     *
     *  * Very small: 0.25f
     *  * Small: 0.5f
     *  * Normal: 1.0f
     *  * Large: 1.5f
     *  * Very large: 2.0f
     *
     *
     * @param context Android app context
     * @return caption scaling
     */
    fun getCaptionScale(context: Context): Float {
        val captioningManager = ContextCompat.getSystemService(context, CaptioningManager::class.java)
        if (captioningManager == null || !captioningManager.isEnabled) return 1.0f
        return captioningManager.fontScale
    }

    /**
     * @param context the Android context
     * @return the screen brightness to use. A value less than 0 (the default) means to use the
     * preferred screen brightness
     */
    fun getScreenBrightness(context: Context): Float {
        val sp = getPreferences(context)
        val timestamp = sp.getLong(context.getString(R.string.screen_brightness_timestamp_key), 0)
        // Hypothesis: 4h covers a viewing block, e.g. evening.
        // External lightning conditions will change in the next
        // viewing block so we fall back to the default brightness
        return if ((System.currentTimeMillis() - timestamp) > TimeUnit.HOURS.toMillis(4)) (-1).toFloat()
        else sp.getFloat(context.getString(R.string.screen_brightness_key), -1f)
    }

    fun setScreenBrightness(context: Context, screenBrightness: Float) {
        getPreferences(context).edit()
            .putFloat(context.getString(R.string.screen_brightness_key), screenBrightness)
            .putLong(context.getString(R.string.screen_brightness_timestamp_key), System.currentTimeMillis())
            .apply()
    }

    fun globalScreenOrientationLocked(context: Context): Boolean {
        // 1: Screen orientation changes using accelerometer
        // 0: Screen orientation is locked
        // if the accelerometer sensor is missing completely, assume locked orientation
        return (Settings.System.getInt(context.contentResolver, Settings.System.ACCELEROMETER_ROTATION, 0) == 0
                || !context.packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_ACCELEROMETER))
    }

    @JvmStatic
    fun getProgressiveLoadIntervalBytes(context: Context): Int {
        val preferredIntervalBytes = getPreferences(context).getString(context.getString(R.string.progressive_load_interval_key), context.getString(R.string.progressive_load_interval_default_value))

        if (context.getString(R.string.progressive_load_interval_exoplayer_default_value) == preferredIntervalBytes)
            return ProgressiveMediaSource.DEFAULT_LOADING_CHECK_INTERVAL_BYTES

        // Keeping the same KiB unit used by ProgressiveMediaSource
        return preferredIntervalBytes!!.toInt() * 1024
    }

    ////////////////////////////////////////////////////////////////////////////
    // Private helpers
    ////////////////////////////////////////////////////////////////////////////
    private fun getPreferences(context: Context): SharedPreferences {
        return PreferenceManager.getDefaultSharedPreferences(context)
    }

    private fun isUsingInexactSeek(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.use_inexact_seek_key), false)
    }

    private fun getAutoQueuedSinglePlayQueue(streamInfoItem: StreamInfoItem?): SinglePlayQueue {
        val singlePlayQueue = SinglePlayQueue(streamInfoItem)
        singlePlayQueue.item?.isAutoQueued = true
        return singlePlayQueue
    }

    ////////////////////////////////////////////////////////////////////////////
    // Utils used by player
    ////////////////////////////////////////////////////////////////////////////
    fun nextRepeatMode(repeatMode: @Player.RepeatMode Int): @Player.RepeatMode Int {
        return when (repeatMode) {
            Player.REPEAT_MODE_OFF -> Player.REPEAT_MODE_ONE
            Player.REPEAT_MODE_ONE -> Player.REPEAT_MODE_ALL
            Player.REPEAT_MODE_ALL -> Player.REPEAT_MODE_OFF
            else -> Player.REPEAT_MODE_OFF
        }
    }

    fun retrieveResizeModeFromPrefs(player: org.schabi.newpipe.player.Player): @ResizeMode Int {
        return player.prefs.getInt(player.context.getString(R.string.last_resize_mode), AspectRatioFrameLayout.RESIZE_MODE_FIT)
    }

    @SuppressLint("SwitchIntDef") // only fit, fill and zoom are supported by NewPipe
    fun nextResizeModeAndSaveToPrefs(player: org.schabi.newpipe.player.Player, resizeMode: @ResizeMode Int): @ResizeMode Int {
        val newResizeMode = when (resizeMode) {
            AspectRatioFrameLayout.RESIZE_MODE_FIT -> AspectRatioFrameLayout.RESIZE_MODE_FILL
            AspectRatioFrameLayout.RESIZE_MODE_FILL -> AspectRatioFrameLayout.RESIZE_MODE_ZOOM
            AspectRatioFrameLayout.RESIZE_MODE_ZOOM -> AspectRatioFrameLayout.RESIZE_MODE_FIT
            else -> AspectRatioFrameLayout.RESIZE_MODE_FIT
        }
        // save the new resize mode so it can be restored in a future session
        player.prefs.edit().putInt(player.context.getString(R.string.last_resize_mode), newResizeMode).apply()
        return newResizeMode
    }

    fun retrievePlaybackParametersFromPrefs(player: org.schabi.newpipe.player.Player): PlaybackParameters {
        val speed = player.prefs.getFloat(player.context.getString(
            R.string.playback_speed_key), player.playbackSpeed)
        val pitch = player.prefs.getFloat(player.context.getString(
            R.string.playback_pitch_key), player.playbackPitch)
        return PlaybackParameters(speed, pitch)
    }

    fun savePlaybackParametersToPrefs(player: org.schabi.newpipe.player.Player, speed: Float, pitch: Float, skipSilence: Boolean) {
        player.prefs.edit()
            .putFloat(player.context.getString(R.string.playback_speed_key), speed)
            .putFloat(player.context.getString(R.string.playback_pitch_key), pitch)
            .putBoolean(player.context.getString(R.string.playback_skip_silence_key), skipSilence)
            .apply()
    }

    fun getMinimumVideoHeight(width: Float): Float {
        return width / (16.0f / 9.0f) // Respect the 16:9 ratio that most videos have
    }

    fun retrieveSeekDurationFromPreferences(player: org.schabi.newpipe.player.Player): Int {
        return Objects.requireNonNull(player.prefs.getString(player.context.getString(R.string.seek_duration_key), player.context.getString(R.string.seek_duration_default_value)))!!.toInt()
    }

    @Retention(AnnotationRetention.SOURCE)
    @IntDef(AutoplayType.AUTOPLAY_TYPE_ALWAYS, AutoplayType.AUTOPLAY_TYPE_WIFI, AutoplayType.AUTOPLAY_TYPE_NEVER)
    annotation class AutoplayType {
        companion object {
            const val AUTOPLAY_TYPE_ALWAYS: Int = 0
            const val AUTOPLAY_TYPE_WIFI: Int = 1
            const val AUTOPLAY_TYPE_NEVER: Int = 2
        }
    }

    @Retention(AnnotationRetention.SOURCE)
    @IntDef(MinimizeMode.MINIMIZE_ON_EXIT_MODE_NONE, MinimizeMode.MINIMIZE_ON_EXIT_MODE_BACKGROUND, MinimizeMode.MINIMIZE_ON_EXIT_MODE_POPUP)
    annotation class MinimizeMode {
        companion object {
            const val MINIMIZE_ON_EXIT_MODE_NONE: Int = 0
            const val MINIMIZE_ON_EXIT_MODE_BACKGROUND: Int = 1
            const val MINIMIZE_ON_EXIT_MODE_POPUP: Int = 2
        }
    }
}
