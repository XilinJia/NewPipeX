package org.schabi.newpipe.player.helper

import android.annotation.SuppressLint
import android.content.Context
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.provider.Settings
import android.util.Log
import android.view.accessibility.CaptioningManager
import androidx.annotation.IntDef
import androidx.core.content.ContextCompat
import androidx.preference.PreferenceManager
import androidx.media3.common.PlaybackParameters
import androidx.media3.common.Player
import androidx.media3.common.MimeTypes
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.SeekParameters
import androidx.media3.exoplayer.source.ProgressiveMediaSource
import androidx.media3.exoplayer.trackselection.AdaptiveTrackSelection
import androidx.media3.exoplayer.trackselection.ExoTrackSelection
import androidx.media3.ui.AspectRatioFrameLayout
import androidx.media3.ui.CaptionStyleCompat
import org.schabi.newpipe.R
import org.schabi.newpipe.extractor.MediaFormat
import org.schabi.newpipe.extractor.stream.StreamInfo
import org.schabi.newpipe.extractor.stream.StreamInfoItem
import org.schabi.newpipe.extractor.stream.SubtitlesStream
import org.schabi.newpipe.extractor.utils.Utils
import org.schabi.newpipe.player.playqueue.PlayQueue
import org.schabi.newpipe.player.playqueue.PlayQueueItem
import org.schabi.newpipe.player.playqueue.SinglePlayQueue
import org.schabi.newpipe.util.ListHelper.isMeteredNetwork
import org.schabi.newpipe.util.Logd
import java.text.DecimalFormat
import java.text.NumberFormat
import java.util.*
import java.util.concurrent.TimeUnit

@UnstableApi object PlayerHelper {
    private val STRING_BUILDER = StringBuilder()
    private val STRING_FORMATTER = Formatter(STRING_BUILDER, Locale.getDefault())
    private val SPEED_FORMATTER: NumberFormat = DecimalFormat("0.##x")
    private val PITCH_FORMATTER: NumberFormat = DecimalFormat("##%")

    ////////////////////////////////////////////////////////////////////////////
    // Exposed helpers
    ////////////////////////////////////////////////////////////////////////////
    fun getTimeString(milliSeconds: Int): String {
        val seconds = (milliSeconds % 60000) / 1000
        val minutes = (milliSeconds % 3600000) / 60000
        val hours = (milliSeconds % 86400000) / 3600000
        val days = (milliSeconds % (86400000 * 7)) / 86400000

        STRING_BUILDER.setLength(0)
        return (when {
            days > 0 -> STRING_FORMATTER.format("%d:%02d:%02d:%02d", days, hours, minutes, seconds)
            hours > 0 -> STRING_FORMATTER.format("%d:%02d:%02d", hours, minutes, seconds)
            else -> STRING_FORMATTER.format("%02d:%02d", minutes, seconds)
        }).toString()
    }

    @JvmStatic
    fun formatSpeed(speed: Double): String {
        return SPEED_FORMATTER.format(speed)
    }

    @JvmStatic
    fun formatPitch(pitch: Double): String {
        return PITCH_FORMATTER.format(pitch)
    }

    fun subtitleMimeTypesOf(format: MediaFormat): String {
        return when (format) {
            MediaFormat.VTT -> MimeTypes.TEXT_VTT
            MediaFormat.TTML -> MimeTypes.APPLICATION_TTML
            else -> throw IllegalArgumentException("Unrecognized mime type: " + format.name)
        }
    }

    fun captionLanguageOf(context: Context, subtitles: SubtitlesStream): String {
        val displayName = subtitles.displayLanguageName
        return displayName + (if (subtitles.isAutoGenerated) " (${context.getString(R.string.caption_auto_generated)})" else "")
    }

    fun captionLanguageStemOf(language: String): String {
        if (!language.contains("(") || !language.contains(")")) return language

        if (language.startsWith("(")) {
            // language text is right-to-left
            val parts = language.split("\\)".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            return parts[parts.size - 1].trim { it <= ' ' }
        }

        return language.split("\\(".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0].trim { it <= ' ' }
    }

    fun resizeTypeOf(context: Context, resizeMode: @AspectRatioFrameLayout.ResizeMode Int): String {
        return when (resizeMode) {
            AspectRatioFrameLayout.RESIZE_MODE_FIT -> context.resources.getString(R.string.resize_fit)
            AspectRatioFrameLayout.RESIZE_MODE_FILL -> context.resources.getString(R.string.resize_fill)
            AspectRatioFrameLayout.RESIZE_MODE_ZOOM -> context.resources.getString(R.string.resize_zoom)
            AspectRatioFrameLayout.RESIZE_MODE_FIXED_HEIGHT, AspectRatioFrameLayout.RESIZE_MODE_FIXED_WIDTH -> throw IllegalArgumentException(
                "Unrecognized resize mode: $resizeMode")
            else -> throw IllegalArgumentException("Unrecognized resize mode: $resizeMode")
        }
    }

    /**
     * Given a [StreamInfo] and the existing queue items,
     * provide the [SinglePlayQueue] consisting of the next video for auto queueing.
     *
     *
     * This method detects and prevents cycles by naively checking
     * if a candidate next video's url already exists in the existing items.
     *
     *
     *
     * The first item in [StreamInfo.getRelatedItems] is checked first.
     * If it is non-null and is not part of the existing items, it will be used as the next stream.
     * Otherwise, a random stream with non-repeating url will be selected
     * from the [StreamInfo.getRelatedItems]. Non-stream items are ignored.
     *
     *
     * @param info          currently playing stream
     * @param existingItems existing items in the queue
     * @return [SinglePlayQueue] with the next stream to queue
     */
    fun autoQueueOf(info: StreamInfo, existingItems: List<PlayQueueItem>): PlayQueue? {
        val urls: MutableSet<String> = HashSet(existingItems.size)
        for (item in existingItems) {
            urls.add(item.url)
        }

        val relatedItems = info.relatedItems
        if (Utils.isNullOrEmpty(relatedItems)) return null

        if (relatedItems[0] is StreamInfoItem && !urls.contains(relatedItems[0].url)) {
            return getAutoQueuedSinglePlayQueue(relatedItems[0] as StreamInfoItem)
        }

        val autoQueueItems: MutableList<StreamInfoItem?> = ArrayList()
        for (item in relatedItems) {
            if (item is StreamInfoItem && !urls.contains(item.getUrl())) {
                autoQueueItems.add(item)
            }
        }

        autoQueueItems.shuffle()
        return if (autoQueueItems.isEmpty()) null else getAutoQueuedSinglePlayQueue(autoQueueItems[0])
    }

    ////////////////////////////////////////////////////////////////////////////
    // Settings Resolution
    ////////////////////////////////////////////////////////////////////////////
    fun isResumeAfterAudioFocusGain(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.resume_on_audio_focus_gain_key), false)
    }

    fun getActionForRightGestureSide(context: Context): String? {
        return getPreferences(context).getString(context.getString(R.string.right_gesture_control_key), context.getString(R.string.default_right_gesture_control_value))
    }

    fun getActionForLeftGestureSide(context: Context): String? {
        return getPreferences(context).getString(context.getString(R.string.left_gesture_control_key), context.getString(R.string.default_left_gesture_control_value))
    }

    fun isStartMainPlayerFullscreenEnabled(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.start_main_player_fullscreen_key), false)
    }

    fun isAutoQueueEnabled(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.auto_queue_key), false)
    }

    fun isClearingQueueConfirmationRequired(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.clear_queue_confirmation_key), false)
    }

    @MinimizeMode
    fun getMinimizeOnExitAction(context: Context): Int {
        val action = getPreferences(context).getString(context.getString(R.string.minimize_on_exit_key), "")
        Logd("PlayerHelper", "getMinimizeOnExitAction: action: $action")
        return when (action) {
            context.getString(R.string.minimize_on_exit_popup_key) -> MinimizeMode.MINIMIZE_ON_EXIT_MODE_POPUP
            context.getString(R.string.minimize_on_exit_none_key) -> MinimizeMode.MINIMIZE_ON_EXIT_MODE_NONE
            else -> MinimizeMode.MINIMIZE_ON_EXIT_MODE_BACKGROUND // default
        }
    }

    @AutoplayType
    fun getAutoplayType(context: Context): Int {
        val type = getPreferences(context).getString(context.getString(R.string.autoplay_key), "")
        return when (type) {
            context.getString(R.string.autoplay_always_key) -> AutoplayType.AUTOPLAY_TYPE_ALWAYS
            context.getString(R.string.autoplay_never_key) -> AutoplayType.AUTOPLAY_TYPE_NEVER
            else -> AutoplayType.AUTOPLAY_TYPE_WIFI // default
        }
    }

    fun isAutoplayAllowedByUser(context: Context): Boolean {
        return when (getAutoplayType(context)) {
            AutoplayType.AUTOPLAY_TYPE_NEVER -> false
            AutoplayType.AUTOPLAY_TYPE_WIFI -> !isMeteredNetwork(context)
            AutoplayType.AUTOPLAY_TYPE_ALWAYS -> true
            else -> true
        }
    }

    fun getSeekParameters(context: Context): SeekParameters {
        return if (isUsingInexactSeek(context)) SeekParameters.CLOSEST_SYNC else SeekParameters.EXACT
    }

    @JvmStatic
    val preferredCacheSize: Long
        get() = 64 * 1024 * 1024L

    val preferredFileSize: Long
        get() = 2 * 1024 * 1024L // ExoPlayer CacheDataSink.MIN_RECOMMENDED_FRAGMENT_SIZE

    val qualitySelector: ExoTrackSelection.Factory
        get() = AdaptiveTrackSelection.Factory(
            1000,
            AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
            AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
            AdaptiveTrackSelection.DEFAULT_BANDWIDTH_FRACTION)

    val isUsingDSP: Boolean
        get() = true

    fun getCaptionStyle(context: Context): CaptionStyleCompat {
        val captioningManager = ContextCompat.getSystemService(context, CaptioningManager::class.java)
        if (captioningManager == null || !captioningManager.isEnabled) return CaptionStyleCompat.DEFAULT

        return CaptionStyleCompat.createFromCaptionStyle(captioningManager.userStyle)
    }

    /**
     * Get scaling for captions based on system font scaling.
     *
     * Options:
     *
     *  * Very small: 0.25f
     *  * Small: 0.5f
     *  * Normal: 1.0f
     *  * Large: 1.5f
     *  * Very large: 2.0f
     *
     *
     * @param context Android app context
     * @return caption scaling
     */
    fun getCaptionScale(context: Context): Float {
        val captioningManager = ContextCompat.getSystemService(context, CaptioningManager::class.java)
        if (captioningManager == null || !captioningManager.isEnabled) return 1.0f
        return captioningManager.fontScale
    }

    /**
     * @param context the Android context
     * @return the screen brightness to use. A value less than 0 (the default) means to use the
     * preferred screen brightness
     */
    fun getScreenBrightness(context: Context): Float {
        val sp = getPreferences(context)
        val timestamp = sp.getLong(context.getString(R.string.screen_brightness_timestamp_key), 0)
        // Hypothesis: 4h covers a viewing block, e.g. evening.
        // External lightning conditions will change in the next
        // viewing block so we fall back to the default brightness
        return if ((System.currentTimeMillis() - timestamp) > TimeUnit.HOURS.toMillis(4)) (-1).toFloat()
        else sp.getFloat(context.getString(R.string.screen_brightness_key), -1f)
    }

    fun setScreenBrightness(context: Context, screenBrightness: Float) {
        getPreferences(context).edit()
            .putFloat(context.getString(R.string.screen_brightness_key), screenBrightness)
            .putLong(context.getString(R.string.screen_brightness_timestamp_key), System.currentTimeMillis())
            .apply()
    }

    fun globalScreenOrientationLocked(context: Context): Boolean {
        // 1: Screen orientation changes using accelerometer
        // 0: Screen orientation is locked
        // if the accelerometer sensor is missing completely, assume locked orientation
        return (Settings.System.getInt(context.contentResolver, Settings.System.ACCELEROMETER_ROTATION, 0) == 0
                || !context.packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_ACCELEROMETER))
    }

    @JvmStatic
    fun getProgressiveLoadIntervalBytes(context: Context): Int {
        val preferredIntervalBytes = getPreferences(context).getString(context.getString(R.string.progressive_load_interval_key), context.getString(R.string.progressive_load_interval_default_value))

        if (context.getString(R.string.progressive_load_interval_exoplayer_default_value) == preferredIntervalBytes) return ProgressiveMediaSource.DEFAULT_LOADING_CHECK_INTERVAL_BYTES

        // Keeping the same KiB unit used by ProgressiveMediaSource
        return preferredIntervalBytes!!.toInt() * 1024
    }

    ////////////////////////////////////////////////////////////////////////////
    // Private helpers
    ////////////////////////////////////////////////////////////////////////////
    private fun getPreferences(context: Context): SharedPreferences {
        return PreferenceManager.getDefaultSharedPreferences(context)
    }

    private fun isUsingInexactSeek(context: Context): Boolean {
        return getPreferences(context).getBoolean(context.getString(R.string.use_inexact_seek_key), false)
    }

    private fun getAutoQueuedSinglePlayQueue(streamInfoItem: StreamInfoItem?): SinglePlayQueue {
        val singlePlayQueue = SinglePlayQueue(streamInfoItem)
        singlePlayQueue.item?.isAutoQueued = true
        return singlePlayQueue
    }

    ////////////////////////////////////////////////////////////////////////////
    // Utils used by player
    ////////////////////////////////////////////////////////////////////////////
    fun nextRepeatMode(repeatMode: @Player.RepeatMode Int): @Player.RepeatMode Int {
        return when (repeatMode) {
            Player.REPEAT_MODE_OFF -> Player.REPEAT_MODE_ONE
            Player.REPEAT_MODE_ONE -> Player.REPEAT_MODE_ALL
            Player.REPEAT_MODE_ALL -> Player.REPEAT_MODE_OFF
            else -> Player.REPEAT_MODE_OFF
        }
    }

    fun retrieveResizeModeFromPrefs(playerManager: org.schabi.newpipe.player.PlayerManager): @AspectRatioFrameLayout.ResizeMode Int {
        return playerManager.prefs.getInt(playerManager.context.getString(R.string.last_resize_mode), AspectRatioFrameLayout.RESIZE_MODE_FIT)
    }

    @SuppressLint("SwitchIntDef") // only fit, fill and zoom are supported by NewPipe
    fun nextResizeModeAndSaveToPrefs(playerManager: org.schabi.newpipe.player.PlayerManager, resizeMode: @AspectRatioFrameLayout.ResizeMode Int): @AspectRatioFrameLayout.ResizeMode Int {
        val newResizeMode = when (resizeMode) {
            AspectRatioFrameLayout.RESIZE_MODE_FIT -> AspectRatioFrameLayout.RESIZE_MODE_FILL
            AspectRatioFrameLayout.RESIZE_MODE_FILL -> AspectRatioFrameLayout.RESIZE_MODE_ZOOM
            AspectRatioFrameLayout.RESIZE_MODE_ZOOM -> AspectRatioFrameLayout.RESIZE_MODE_FIT
            else -> AspectRatioFrameLayout.RESIZE_MODE_FIT
        }
        // save the new resize mode so it can be restored in a future session
        playerManager.prefs.edit().putInt(playerManager.context.getString(R.string.last_resize_mode), newResizeMode).apply()
        return newResizeMode
    }

    fun retrievePlaybackParametersFromPrefs(playerManager: org.schabi.newpipe.player.PlayerManager): PlaybackParameters {
        val speed = playerManager.prefs.getFloat(playerManager.context.getString(
            R.string.playback_speed_key), playerManager.playbackSpeed)
        val pitch = playerManager.prefs.getFloat(playerManager.context.getString(
            R.string.playback_pitch_key), playerManager.playbackPitch)
        return PlaybackParameters(speed, pitch)
    }

    fun savePlaybackParametersToPrefs(playerManager: org.schabi.newpipe.player.PlayerManager, speed: Float, pitch: Float, skipSilence: Boolean) {
        playerManager.prefs.edit()
            .putFloat(playerManager.context.getString(R.string.playback_speed_key), speed)
            .putFloat(playerManager.context.getString(R.string.playback_pitch_key), pitch)
            .putBoolean(playerManager.context.getString(R.string.playback_skip_silence_key), skipSilence)
            .apply()
    }

    fun getMinimumVideoHeight(width: Float): Float {
        return width / (16.0f / 9.0f) // Respect the 16:9 ratio that most videos have
    }

    fun retrieveSeekDurationFromPreferences(playerManager: org.schabi.newpipe.player.PlayerManager): Int {
        return Objects.requireNonNull(playerManager.prefs.getString(playerManager.context.getString(R.string.seek_duration_key), playerManager.context.getString(R.string.seek_duration_default_value)))!!.toInt()
    }

    @Retention(AnnotationRetention.SOURCE)
    @IntDef(AutoplayType.AUTOPLAY_TYPE_ALWAYS, AutoplayType.AUTOPLAY_TYPE_WIFI, AutoplayType.AUTOPLAY_TYPE_NEVER)
    annotation class AutoplayType {
        companion object {
            const val AUTOPLAY_TYPE_ALWAYS: Int = 0
            const val AUTOPLAY_TYPE_WIFI: Int = 1
            const val AUTOPLAY_TYPE_NEVER: Int = 2
        }
    }

    @Retention(AnnotationRetention.SOURCE)
    @IntDef(MinimizeMode.MINIMIZE_ON_EXIT_MODE_NONE, MinimizeMode.MINIMIZE_ON_EXIT_MODE_BACKGROUND, MinimizeMode.MINIMIZE_ON_EXIT_MODE_POPUP)
    annotation class MinimizeMode {
        companion object {
            const val MINIMIZE_ON_EXIT_MODE_NONE: Int = 0
            const val MINIMIZE_ON_EXIT_MODE_BACKGROUND: Int = 1
            const val MINIMIZE_ON_EXIT_MODE_POPUP: Int = 2
        }
    }
}
